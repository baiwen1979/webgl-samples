<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>WebGL Spheres</title>    <link rel="stylesheet" href="css/default.css" /></head><body><canvas id="canvas"><p>您的浏览器不支持HTML5画布</p></canvas><div id="fps"></div><!-- 顶点着色器 --><script id="vertex-shader-3d" type="x-shader/x-vertex">//GLSL代码//uniform变量uniform mat4 u_worldViewProjection; //世界视图投影矩阵uniform vec3 u_lightWorldPos; //灯光的世界坐标uniform mat4 u_world; //世界矩阵uniform mat4 u_viewInverse; //视图（观察点）反转（逆）矩阵uniform mat4 u_worldInverseTranspose; //世界反转（逆）矩阵的转置矩阵//attribute变量attribute vec4 a_position; //顶点坐标attribute vec3 a_normal; //法向量attribute vec2 a_texcoord; //纹理坐标//varying变量，用来向片元着色器传值，并内插varying vec4 v_position; //顶点坐标varying vec2 v_texCoord; //纹理坐标varying vec3 v_normal; //法向量varying vec3 v_surfaceToLight; //表面（各顶点）指向光源的向量varying vec3 v_surfaceToView; //表面（各顶点）指向观察点的向量//着色器程序主函数void main() {  v_texCoord = a_texcoord; //传递（每）顶点的纹理坐标  v_position = (u_worldViewProjection * a_position); //计算并传递（每）顶点的世界视图投影坐标  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz; //计算并传递（每）顶点法向量  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz; //计算并传递（每）顶点指向光源的向量  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz; //计算并传递（每）顶点指向观察点的向量  gl_Position = v_position;//设置当前顶点坐标}</script><!-- 片元着色器 --><script id="fragment-shader-3d" type="x-shader/x-fragment">precision mediump float; //设置浮点精度为中等varying vec4 v_position; //顶点位置坐标varying vec2 v_texCoord; //纹理坐标varying vec3 v_normal; //法向量varying vec3 v_surfaceToLight; //面光向量varying vec3 v_surfaceToView; //面视向量uniform vec4 u_lightColor; //灯光颜色uniform vec4 u_colorMult; //环境光颜色uniform sampler2D u_diffuse; //漫反射颜色uniform vec4 u_specular; //高光uniform float u_shininess; //发光度uniform float u_specularFactor; //高光因子//光照函数，用来计算光照向量vec4 lit(float l ,float h, float m) {  return vec4(1.0,              abs(l),              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,              1.0);}//着色器程序主函数void main() {  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord); //根据纹理坐标计算漫反射颜色  vec3 a_normal = normalize(v_normal); //对插值的法向量归一化  vec3 surfaceToLight = normalize(v_surfaceToLight); //对面光向量进行归一化  vec3 surfaceToView = normalize(v_surfaceToView); //对面视向量进行归一化  vec3 halfVector = normalize(surfaceToLight + surfaceToView); //计算面光向量和面视向量的中间向量，并归一化  vec4 litR = lit(dot(a_normal, surfaceToLight), dot(a_normal, halfVector), u_shininess);//计算光照向量  vec4 outColor = vec4((u_lightColor * (diffuseColor * litR.y * u_colorMult +                u_specular * litR.z * u_specularFactor)).rgb,diffuseColor.a); //计算最终的输出颜色  gl_FragColor = outColor; //设置片元颜色  //gl_FragColor = vec4(litR.yyy, 1);}</script><script src="lib/wegl-utils.js"></script><script src="lib/m4.js"></script><script src="lib/primitives.js"></script><script src="lib/texture-utils.js"></script><script src="lib/chroma.min.js"></script><script src="js/spheres.js"></script></body></html>