/** * Created by xiaobai on 2017/6/9. */"use strict";function updateFPS(deltaTime) {    var fpsDiv = document.getElementById('fps');    fpsDiv.innerHTML = "FPS:" + Math.floor(1000.0 / deltaTime);}function main() {    var canvas = document.getElementById('canvas');    var gl = canvas.getContext('webgl');    if (!gl) {        return;    }    var createFlattenedVertices = function (gl, vertices) {        return webglUtils.createBufferInfoFromArrays(            gl,            primitives.makeRandomVertexColors(                primitives.deindexVertices(vertices),                {                    vertsPerColor: 6,                    rand: function(ndx, channel) {                        return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;                    }                })        );    };    // 创建几何体对象的缓冲区信息    var sphereBufferInfo = createFlattenedVertices(gl, primitives.createSphereVertices(10, 24, 12));    var cubeBufferInfo = createFlattenedVertices(gl, primitives.createCubeVertices(20));    var coneBufferInfo = createFlattenedVertices(gl, primitives.createTruncatedConeVertices(10, 0, 20, 24, 1, true, false));    // 要绘制的几何体形状，用于随机地从中挑选    var shapes = [        sphereBufferInfo,        cubeBufferInfo,        coneBufferInfo,    ];    // 根据着色器脚本创建GLSL程序信息对象    var programInfo =  webglUtils.createProgramInfo(gl, ["vertex-shader-3d", "fragment-shader-3d"]);    // 角度转化为弧度    function degToRad(d) {        return d * Math.PI / 180;    }    // 摄像机角度    var cameraAngleRadians = degToRad(0);    // 视野    var fieldOfViewRadians = degToRad(60);    // 摄像机高度    var cameraHeight = 50;    // 分别用来绘制和操作的对象数组    var objectsToDraw = [];    var objects = [];    var rand = mathUtils.rand;    var emod = mathUtils.emod;    // 设置每个对象的uniforms变量    var baseHue = rand(0, 360);    var numObjects = 200;    for (var i = 0; i < numObjects; ++i) {        // 随机挑选一个形状        var bufferInfo = shapes[rand(0, shapes.length) | 0];        // 创建对象        var object = {            uniforms: {                u_colorMult: chroma.hsv(emod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),                u_matrix: m4.identity(),            },            translation: [rand(-100, 100), rand(-100, 100), rand(-150, 50)],            xRotationSpeed: rand(0.8, 1.2),            yRotationSpeed: rand(0.8, 1.2),        };        objects.push(object);        objectsToDraw.push({            programInfo: programInfo,            bufferInfo: bufferInfo,            uniforms: object.uniforms,        });    }    function computeMatrix(viewProjectionMatrix, translation, xRotation, yRotation) {        var matrix = m4.translate(viewProjectionMatrix,            translation[0],            translation[1],            translation[2]);        matrix = m4.xRotate(matrix, xRotation);        return m4.yRotate(matrix, yRotation);    };    requestAnimationFrame(drawScene); // 开始动画    var last = 0;    // 绘制场景    function drawScene(time) {        var deltaTime = time - last;        last = time;        time *= 0.0005;        // 将画布的实际大小重置为显示大小        webglUtils.resizeCanvasToDisplaySize(gl.canvas);        // 设置WebGL视口范围（大小），即告诉WebGL如何将裁剪空间转化为像素空间        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);        // 清除颜色和深度缓冲区        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);        // 启用背面剔除操作        gl.enable(gl.CULL_FACE);        // 启用深度测试        gl.enable(gl.DEPTH_TEST);        // 计算投影矩阵        var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; // 计算宽高比        var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000); // 使用透视投影矩阵        // 计算摄像机矩阵        var cameraPosition = [0, 0, 100]; // 摄像机的位置        var target = [0, 0, 0]; // 摄像机目标        var up = [0, 1, 0]; // 摄像机上部        var cameraMatrix = m4.lookAt(cameraPosition, target, up);        // 反转摄像机矩阵得到视图矩阵.        var viewMatrix = m4.inverse(cameraMatrix);        // 计算视图投影矩阵        var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);        // 计算每个对象的变换矩阵        objects.forEach(function(object) {            object.uniforms.u_matrix = computeMatrix(                viewProjectionMatrix,                object.translation,                object.xRotationSpeed * time,                object.yRotationSpeed * time);        });        // 记录上次使用的着色器程序信息和缓冲区信息        var lastUsedProgramInfo = null;        var lastUsedBufferInfo = null;        // 绘制几何体        var drawGeometry = function(geometry) {            var programInfo = geometry.programInfo;            var bufferInfo = geometry.bufferInfo;            var bindBuffers = false;            if (programInfo !== lastUsedProgramInfo) {                lastUsedProgramInfo = programInfo;                // 使用着色器程序                gl.useProgram(programInfo.program);                // 当改变着色器程序时，必须重新绑定缓冲区,因为我们只绑定着色器程序使用的缓冲区。                // 如果两个着色器程序使用了相同的缓冲区信息，而其中之一只使用的位置缓冲，则当切                // 换着色器程序时，其中的属性信息将丢失。                bindBuffers = true;            }            // 设置着色器缓冲区和attribute变量            if (bindBuffers || bufferInfo != lastUsedBufferInfo) {                lastUsedBufferInfo = bufferInfo;                webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);            }            // 设置着色器uniform变量            webglUtils.setUniforms(programInfo, geometry.uniforms);            gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);        };        objectsToDraw.forEach(drawGeometry);        //显示FPS        updateFPS(deltaTime);        //请求下一帧动画        requestAnimationFrame(drawScene);    }}main();