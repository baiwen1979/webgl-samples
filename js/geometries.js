/** * Created by xiaobai on 2017/6/9. */"use strict";function updateFPS(deltaTime) {    var fpsDiv = document.getElementById('fps');    fpsDiv.innerHTML = "FPS:" + Math.floor(1000.0 / deltaTime);}function main() {    var canvas = document.getElementById('canvas');    var gl = canvas.getContext('webgl');    if (!gl) {        return;    }    var createFlattenedVertices = function (gl, vertices) {        return webglUtils.createBufferInfoFromArrays(            gl,            primitives.makeRandomVertexColors(                primitives.deindexVertices(vertices),                {                    vertsPerColor: 6,                    rand: function(ndx, channel) {                        return channel < 3 ? ((128 + Math.random() * 128) | 0) : 255;                    }                })        );    };    // 创建几何体对象的缓冲区信息    var sphereBufferInfo = createFlattenedVertices(gl, primitives.createSphereVertices(30, 24, 12));    var cubeBufferInfo = createFlattenedVertices(gl, primitives.createCubeVertices(40));    var coneBufferInfo = createFlattenedVertices(gl, primitives.createTruncatedConeVertices(30, 0, 40, 24, 1, true, false));    // 根据着色器脚本创建GLSL程序信息对象    var programInfo =  webglUtils.createProgramInfo(gl, ["vertex-shader-3d", "fragment-shader-3d"]);    // 角度转化为弧度    function degToRad(d) {        return d * Math.PI / 180;    }    // 摄像机角度    var cameraAngleRadians = degToRad(0);    // 视野    var fieldOfViewRadians = degToRad(60);    // 摄像机高度    var cameraHeight = 50;    // 几何体对象的uniform变量    var sphereUniforms = {        u_colorMult: [0.5, 1, 0.5, 1], //混合颜色        u_matrix:  m4.identity(),  //变换矩阵    };    var cubeUniforms = {        u_colorMult: [1, 0.5, 0.5, 1], //混合颜色        u_matrix:  m4.identity(),  //变换矩阵    };    var coneUniforms = {        u_colorMult: [0.5, 0.5, 1, 1], //混合颜色        u_matrix:  m4.identity(),  //变换矩阵    };    // 几何体对象的移动位置    var sphereTranslation = [0, 0, 0];    var cubeTranslation = [-60, 0, 0];    var coneTranslation = [60, 0, 0];    var computeMatrix = function (viewProjectionMatrix, translation, xRotation, yRotation) {        var matrix = m4.translate(viewProjectionMatrix,            translation[0],            translation[1],            translation[2]);        matrix = m4.xRotate(matrix, xRotation);        return m4.yRotate(matrix, yRotation);    };    requestAnimationFrame(drawScene); // 开始动画    var last = 0;    // 绘制场景    function drawScene(time) {        var deltaTime = time - last;        last = time;        time *= 0.0005;        // 将画布的实际大小重置为显示大小        webglUtils.resizeCanvasToDisplaySize(gl.canvas);        // 设置WebGL视口范围（大小），即告诉WebGL如何将裁剪空间转化为像素空间        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);        // 清除颜色和深度缓冲区        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);        // 启用背面剔除操作        gl.enable(gl.CULL_FACE);        // 启用深度测试        gl.enable(gl.DEPTH_TEST);        // 计算投影矩阵        var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; // 计算宽高比        var projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000); // 使用透视投影矩阵        // 计算摄像机矩阵        var cameraPosition = [0, 0, 100]; // 摄像机的位置        var target = [0, 0, 0]; // 摄像机目标        var up = [0, 1, 0]; // 摄像机上部        var cameraMatrix = m4.lookAt(cameraPosition, target, up);        // 反转摄像机矩阵得到视图矩阵.        var viewMatrix = m4.inverse(cameraMatrix);        // 计算视图投影矩阵        var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);        var sphereXRotation =  time;        var sphereYRotation =  time;        var cubeXRotation   = -time;        var cubeYRotation   =  time;        var coneXRotation   =  time;        var coneYRotation   = -time;        // 使用着色器程序        gl.useProgram(programInfo.program);        // 绘制几何体        var drawGeometry = function(bufferInfo, geometryUniforms, translation, xRotation, yRotation) {            // 设置着色器缓冲区和attribute变量            webglUtils.setBuffersAndAttributes(gl, programInfo, bufferInfo);            geometryUniforms.u_matrix = computeMatrix(                viewProjectionMatrix,                translation,                xRotation,                yRotation);            // 设置着色器uniform变量            webglUtils.setUniforms(programInfo, geometryUniforms);            gl.drawArrays(gl.TRIANGLES, 0, bufferInfo.numElements);        };        // 绘制球体        drawGeometry(sphereBufferInfo, sphereUniforms, sphereTranslation,            sphereXRotation, sphereYRotation);        // 绘制立方体        drawGeometry(cubeBufferInfo, cubeUniforms, cubeTranslation,            cubeXRotation, cubeYRotation);        // 绘制圆锥体        drawGeometry(coneBufferInfo, coneUniforms, coneTranslation,            coneXRotation, coneYRotation);        //显示FPS        updateFPS(deltaTime);        //请求下一帧动画        requestAnimationFrame(drawScene);    }}main();